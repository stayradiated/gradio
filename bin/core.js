// Generated by CoffeeScript 1.6.2
/**
 * @fileOverview Used to make requests to the internal Grooveshark API
*/


(function() {
  var Core, Country, JsonPost, Token, crypto, http, promise, request, uuid,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  request = require('request');

  promise = require('when');

  http = require('http');

  crypto = require('crypto');

  uuid = require('uuid');

  Token = require('./token');

  JsonPost = require('./jsonPost');

  Country = require('./country');

  /**
   * @class Core
  */


  Core = (function() {
    function Core() {
      this.callMethod = __bind(this.callMethod, this);
      this.getTokenKey = __bind(this.getTokenKey, this);
      this.getToken = __bind(this.getToken, this);
      this.getSecretKey = __bind(this.getSecretKey, this);
      this.getSessionID = __bind(this.getSessionID, this);
      this.init = __bind(this.init, this);      this.domain = 'grooveshark.com';
      this.methodphp = 'more.php';
      this.streamphp = 'stream.php';
      this.methodurl = this.domain + '/' + this.methodphp;
      this.homeurl = 'http://' + this.domain;
      this.jsMethod = ['getStreamKeyFromSongIDEx', 'markSongComplete', 'markSongDownloadedEx', 'markStreamKeyOver30Seconds'];
      this.htmlMethod = ['getCommunicationToken', 'getResultsFromSearch', 'authenticateUser', 'logoutUser', 'playlistAddSongToExisting', 'playlistAddSongToExisting', 'popularGetSongs', 'playlistGetSongs', 'initiateQueue', 'userAddSongsToLibrary', 'userGetPlaylists', 'userGetSongsInLibrary', 'getFavorites', 'favorite', 'getCountry', 'albumGetSongs'];
      this.htmlName = 'htmlshark';
      this.jsName = 'jsqueue';
      this.htmlVersion = '';
      this.jsVersion = '';
      this.swfVersion = '20121003.33';
      this.password = '';
      this.jsReferer = 'http://grooveshark.com/JSQueue.swf?' + this.swfVersion;
      this.htmlReferer = 'http://grooveshark.com/';
      this.userAgent = 'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1';
      this.uuid = uuid.v1();
      this.country = new Country(this);
      this.newTokenTime = 16 * 60 * 1000;
      this.lastTokenTime = 0;
      this.sessionID = '';
      this.secretKey = '';
      this.token = '';
    }

    /**
     * Make all the necessary calls to get the session ID and Token
     * Completely optional
     * @promises {null} can be used to do stuff when everything is ready
    */


    Core.prototype.init = function() {
      var ready;

      ready = promise.all([this.getToken(), this.country.fetch()]);
      ready.then(function() {
        return console.log('> We are online!');
      });
      return ready;
    };

    /**
     * Returns a Grooveshark SessionID which is needed to communicate with the
     * services and generate the secret key.
     * @promises {string} Grooveshark's SessionID
    */


    Core.prototype.getSessionID = function() {
      var deferred,
        _this = this;

      deferred = promise.defer();
      if (this.sessionID.length > 0) {
        deferred.resolve(this.sessionID);
        return deferred.promise;
      }
      console.log('> Getting session id');
      request(this.homeurl, function(err, res, body) {
        var cookies;

        if (err) {
          return deferred.reject(err);
        }
        cookies = res.headers['set-cookie'];
        _this.sessionID = cookies[0].split('=')[1].split(';')[0];
        return deferred.resolve(_this.sessionID);
      });
      return deferred.promise;
    };

    /**
     * Generates the SecretKey from the SessionID needed to get the communication
     * Token and return s it. If getSessionID() hasn't already been called, it
     * will do it automagically
     * @promises {string} SessionID's SecretKey
     * @throws Error if it can't get a session ID
    */


    Core.prototype.getSecretKey = function() {
      var deferred,
        _this = this;

      deferred = promise.defer();
      if (this.secretKey.length > 0) {
        deferred.resolve(this.secretKey);
        return deferred.promise;
      }
      this.getSessionID().then(function(sessionID) {
        var md5;

        console.log('> Getting secret key');
        md5 = crypto.createHash('md5');
        md5.update(sessionID, 'utf-8');
        _this.secretKey = md5.digest('hex');
        return deferred.resolve(_this.secretKey);
      }, function(err) {
        throw new Error(err);
      });
      return deferred.promise;
    };

    /**
     * Returns the communication token needed to communicate with GrooveShark.
     * @promises {string} Communication token
    */


    Core.prototype.getToken = function() {
      var deferred, timeNow,
        _this = this;

      deferred = promise.defer();
      timeNow = Date.now();
      if (this.token.length > 0 && (timeNow - this.lastTokenTime) < this.newTokenTime) {
        deferred.resolve(this.token);
        return deferred.promise;
      }
      this.getSecretKey().then(function(secretKey) {
        var parameters;

        console.log('> Getting token');
        parameters = {
          secretKey: secretKey
        };
        return _this.callMethod(parameters, 'getCommunicationToken', 'https');
      }).then(function(response) {
        _this.token = response.result;
        _this.lastTokenTime = timeNow;
        return deferred.resolve(_this.token);
      });
      return deferred.promise;
    };

    /**
     * Generate the TokenKey using Grooveshark's hacked password and the method
     * to call a service correctly.
     * @param  {string} method The service to call
     * @promises {string} The hashed token
    */


    Core.prototype.getTokenKey = function(method) {
      var deferred,
        _this = this;

      deferred = promise.defer();
      this.getToken().then(function(token) {
        var hashhex, pass, pos, randomhex, sha1;

        console.log('> Getting token key');
        randomhex = '';
        while (6 > randomhex.length) {
          pos = Math.floor(Math.random() * 16);
          randomhex += "0123456789abcdef".charAt(pos);
        }
        if (__indexOf.call(_this.jsMethod, method) >= 0) {
          _this.password = Token.jsToken;
          _this.versionJS = Token.jsVersion;
        } else if (__indexOf.call(_this.htmlMethod, method) >= 0) {
          _this.password = Token.htmlToken;
          _this.versionHTML = Token.htmlVersion;
        }
        pass = method + ':' + token + ':' + _this.password + ':' + randomhex;
        sha1 = crypto.createHash('sha1');
        hashhex = sha1.update(pass).digest('hex');
        return deferred.resolve(randomhex + hashhex);
      });
      return deferred.promise;
    };

    /**
     * Uses the token key and session ID to get a response from Grooveshark
     * using the desired method. The parameters must be specified.
     * @param {object} parameters - Parameters for the method
     * @param {string} method - The service to call
     * @param {string} protocol - The protocol to use
     * @promises {object} The JSON data returned from the request
    */


    Core.prototype.callMethod = function(parameters, method, protocol) {
      var deferred, makeRequest, start, url,
        _this = this;

      if (protocol == null) {
        protocol = 'http';
      }
      deferred = promise.defer();
      start = Date.now();
      url = protocol + '://' + this.methodurl + '?' + method;
      makeRequest = function(json) {
        var options;

        console.log("> Calling '" + method + "'");
        options = {
          url: url,
          method: 'POST',
          body: json.toString(),
          headers: {
            'Referer': 'http://grooveshark.com/'
          }
        };
        return request(options, function(err, res, body) {
          var end;

          if (err) {
            return deferred.reject(err);
          }
          end = Date.now();
          console.log('> ', (end - start) / 1000, 'seconds');
          return deferred.resolve(JSON.parse(body));
        });
      };
      new JsonPost(this, parameters, method).then(function(json) {
        if (method !== 'getCommunicationToken') {
          return _this.getTokenKey(method).then(function(token) {
            json.header.token = token;
            return makeRequest(json);
          });
        } else {
          return makeRequest(json);
        }
      });
      return deferred.promise;
    };

    /**
     * Returns the song audio stream corresponded to the streamKey passed, it
     * can be used to store it on disk or play it.
     * IMPORTANT!: When using this method markSongAsDownloaded and
     * markSongComplete should be used to avoid Grooveshark heuristics to detect
     * this as an attack.
     * @param {string} ip - The IP of the host where the song is stored
     * @param {string} streamKey - The StreamKey identifies the song
     * @return {stream} Audio stream of the song
    */


    Core.prototype.getSongStream = function(ip, streamKey) {
      var contents, deferred, options, req;

      deferred = promise.defer();
      contents = 'streamKey=' + streamKey.replace(/_/g, '%5F');
      options = {
        hostname: ip,
        path: '/' + this.streamphp,
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
          'Content-Length': contents.length,
          'Referer': 'http://' + this.domain + '/JSQueue.swf?' + this.versionSwf
        }
      };
      req = http.request(options, function(res) {
        var body, length, notify, progress;

        length = parseInt(res.headers['content-length'], 10);
        progress = 0;
        console.log(Math.round(length / 1024 / 1024) + 'mb');
        notify = function() {
          var now;

          now = Math.floor(body.length / length * 100);
          if (now > progress) {
            progress = now;
            return deferred.notify(progress);
          }
        };
        body = "";
        res.on('data', function(chunk) {
          body += chunk.toString('binary');
          return notify();
        });
        return res.on('end', function() {
          return deferred.resolve(body);
        });
      });
      req.write(contents);
      req.on('error', function(e) {
        return console.log('error', e.message);
      });
      req.end();
      return deferred.promise;
    };

    return Core;

  })();

  module.exports = Core;

}).call(this);
